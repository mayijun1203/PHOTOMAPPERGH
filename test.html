<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>

    <script src='https://api.mapbox.com/mapbox-gl-js/v2.12.0/mapbox-gl.js'></script>
    <link href='https://api.mapbox.com/mapbox-gl-js/v2.12.0/mapbox-gl.css' rel='stylesheet' />
    <script src='https://unpkg.com/@turf/turf@6/turf.min.js'></script>
    <script src="https://cdn.jsdelivr.net/npm/mapboxgl-spiderifier@1.0.10/index.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/mapboxgl-spiderifier@1.0.10/index.min.css" rel="stylesheet">

    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: sans-serif;
        }

        #mainmap {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 100%;
        }
    </style>
</head>

<body>
    <div class="container-fluid p-0" id="mainmap"> </div> <!-- placeholder for main map -->

    <script>
        'use strict';
        // Set MapBox token
        mapboxgl.accessToken = 'pk.eyJ1IjoibWF5aWp1biIsImEiOiJjaXg4ZmlyY20wMDBjMm9tcjI0bjQ0Z21zIn0.Io0XJ4JelN903V9HGo4TfQ'; // still need to find a way to store the token


        // Initialize the map
        const map = new mapboxgl.Map({ // creating a new map
            container: 'mainmap', // same as the div id to place the map
            maxZoom: 22, // max zoom levl
            style: 'mapbox://styles/mapbox/light-v10', // light base map
            hash: true, // make sure it's on to get the url with map view
            preserveDrawingBuffer: true, // make sure it's on to allow printing
            center: [119.655953, 29.093875], // testing to get the centroid of bounds
            zoom: 11, // set the initial zoom of the map view
        });

        // // Auto fitting to the bounds
        // fetch('https://raw.githubusercontent.com/mayijun1203/PHOTOVIZGH/main/photoattr.geojson')
        //     .then((response) => response.json())
        //     .then((data) => map.fitBounds(turf.bbox(data), { padding: 100 }));


        // Add layers
        map.on('load', function () {
            map.loadImage(
                'icon.png',
                (error, image) => {
                    if (error) throw error;

                    // Add the image to the map style.
                    map.addImage('dirArrow', image);


                    const layerContentList = []; // store all the layer contents

                    // Add full screen control
                    map.addControl(new mapboxgl.FullscreenControl({
                        container: document.querySelector('body'),
                    }),
                        'bottom-left', // control position
                    );

                    // Add navigation control
                    map.addControl(new mapboxgl.NavigationControl({
                        showCompass: true, // show compass
                        showZoom: true, // show zoom
                        visualizePitch: true, // show pitch
                    }),
                        'bottom-left', // control position
                    );


                    // Add points
                    // Set layer contents
                    const layerContent = {
                        'sourceId': 'photoattr', // source id
                        'sourceType': 'geojson', // source type
                        'sourceData': 'https://raw.githubusercontent.com/mayijun1203/PHOTOVIZGH/main/photoattr.geojson', // data source
                        'cluster': true, // whether enable clustering
                        'clusterMaxZoom': 22, // max zoom level for clustering
                        'clusterRadius': 20, // radius of clusters
                        'unclusteredId': 'unclustered', // layer id
                        'unclusteredType': 'symbol', // symbology type
                        'unclusteredVisibility': 'visible', // visibility of the layer
                        'unclusteredOverlap': true, // icon allow overlap
                        'unclusteredOpacity': 1, // icon opacity
                        'unclusteredSize': 0.07, // icon radius
                        'unclusteredRotate': ['get', 'bearing'], // icon rotate
                        'unclusteredOutlineColor': 'rgba(255,255,255,0)',  // outline color; for legend purpose only
                        'clusteredId': 'clustered', // layer id
                        'clusteredType': 'circle', // symbology type
                        'clusteredVisibility': 'visible', // visibility of the layer
                        'clusteredColor': ['step', ['get', 'point_count'], '#ffcd03', 5, '#a3cf62', 10, '#00a9a5'], // color for each category; use rgba
                        'clusteredOpacity': 1, // circle opacity
                        'clusteredRadius': ['step', ['get', 'point_count'], 20, 100, 30, 750, 40], // circle radius; change size based on point counts
                        'clusteredStrokeColor': 'rgb(255,255,255)', // circle stroke color
                        'clusteredStrokeOpacity': 1, // circle stroke opacity
                        'clusteredStrokeWidth': 0, // circle stroke width
                        'clusteredOutlineColor': 'rgba(255,255,255,0)',  // outline color; for legend purpose only
                        'clusterLabelId': 'clusterlabel',
                        'clusterLabelType': 'symbol', // symbology type
                        'clusterLabelVisibility': 'visible', // visibility of the layer
                        'clusterLabelOverlap': true, // text allow overlap
                        'clusterLabelTextField': ['get', 'point_count_abbreviated'], // text for the cluster label
                        'clusterLabelTextFont': ['Open Sans Semibold', 'Arial Unicode MS Bold'], // text font for the cluster label
                        'clusterLabelTextSize': 14, // text size for the cluster label
                    };

                    // Add layer content to the overall layer content list
                    layerContentList.push(layerContent);

                    // Add data source
                    map.addSource(layerContent['sourceId'], {
                        'type': layerContent['sourceType'],
                        'data': layerContent['sourceData'],
                        'cluster': layerContent['cluster'],
                        'clusterMaxZoom': layerContent['clusterMaxZoom'],
                        'clusterRadius': layerContent['clusterRadius'],
                    });

                    // Add clustered circle layer
                    map.addLayer({
                        'id': layerContent['clusteredId'],
                        'type': layerContent['clusteredType'],
                        'source': layerContent['sourceId'],
                        'filter': ['has', 'point_count'],
                        'layout': {
                            'visibility': layerContent['clusteredVisibility'],
                        },
                        'paint': {
                            'circle-color': layerContent['clusteredColor'],
                            'circle-opacity': layerContent['clusteredOpacity'],
                            'circle-radius': layerContent['clusteredRadius'],
                            'circle-stroke-color': layerContent['clusteredStrokeColor'],
                            'circle-stroke-opacity': layerContent['clusteredStrokeOpacity'],
                            'circle-stroke-width': layerContent['clusteredStrokeWidth'],
                        },
                    });

                    // Add clustered label layer
                    map.addLayer({
                        'id': layerContent['clusterLabelId'],
                        'type': layerContent['clusterLabelType'],
                        'source': layerContent['sourceId'],
                        'filter': ['has', 'point_count'],
                        'layout': {
                            'visibility': layerContent['clusterLabelVisibility'],
                            'text-allow-overlap': layerContent['clusterLabelOverlap'],
                            'text-field': layerContent['clusterLabelTextField'],
                            'text-font': layerContent['clusterLabelTextFont'],
                            'text-size': layerContent['clusterLabelTextSize'],
                        },
                    });

                    // Add unclustered circle layer
                    map.addLayer({
                        'id': layerContent['unclusteredId'],
                        'type': layerContent['unclusteredType'],
                        'source': layerContent['sourceId'],
                        'filter': ['!', ['has', 'point_count']],
                        'layout': {
                            'visibility': layerContent['unclusteredVisibility'],
                            'icon-allow-overlap': layerContent['unclusteredOverlap'],
                            'icon-image': 'dirArrow',
                            'icon-size': layerContent['unclusteredSize'],
                            'icon-rotate': layerContent['unclusteredRotate'],
                        },
                        'paint': {
                            'icon-opacity': layerContent['unclusteredOpacity'],
                        },
                    });


                    // Click on a cluster
                    map.on('click', 'clustered', (e) => {
                        if (map.getZoom() < 1) {
                            let features = map.queryRenderedFeatures(e.point, {
                                layers: ['clustered'],
                            });
                            let clusterId = features[0].properties.cluster_id;
                            map.getSource('photoattr').getClusterExpansionZoom(
                                clusterId,
                                (err, zoom) => {
                                    if (err) return;
                                    map.easeTo({
                                        center: features[0].geometry.coordinates,
                                        zoom: zoom,
                                    });
                                }
                            );
                        } else {
                            let spiderifier = new MapboxglSpiderifier(map, {
                                initializeLeg: function (spiderLeg) {
                                    // Add popup
                                    let spiderPopup = new mapboxgl.Popup({
                                        closeButton: true, // close button
                                        closeOnClick: true, // close if click on map
                                        closeOnMove: false, // close if move the map
                                        anchor: 'bottom', // anchor of the popup
                                        maxWidth: 'none', // max width of the popoup; 'none' to fit to the content                
                                        offset: MapboxglSpiderifier.popupOffsetForSpiderLeg(spiderLeg),
                                    });
                                    let description = "<b>Photo ID: </b><span>" + spiderLeg.feature.photo + "</span><br>"; // description in the popup
                                    description += "<b>Datetime: </b><span>" + spiderLeg.feature.datetime + "</span><br>";
                                    description += "<a target='_blank' href='https://raw.githubusercontent.com/mayijun1203/PHOTOVIZGH/main/photo/" + spiderLeg.feature.photo + "'><img src='https://raw.githubusercontent.com/mayijun1203/PHOTOVIZGH/main/photo/" + spiderLeg.feature.photo + "' width=300rem>";
                                    spiderPopup.setHTML(description);
                                    spiderLeg.mapboxMarker.setPopup(spiderPopup);
                                    // Unspiderfy if zoomed with no popup opened
                                    map.on('zoom', () => {
                                        if (document.getElementsByClassName('mapboxgl-popup-content').length == 0) {
                                            spiderifier.unspiderfy();
                                        };
                                    });
                                }
                            });
                            spiderifier.unspiderfy();

                            let features = map.queryRenderedFeatures(e.point, {
                                layers: ['clustered'],
                            });
                            let clusterId = features[0].properties.cluster_id;
                            map.getSource('photoattr').getClusterLeaves(
                                clusterId, 100, 0,
                                (err, leaves) => {
                                    if (err) return;
                                    let markers = [];
                                    for (let i = 0; i < leaves.length; i++) {
                                        markers.push(leaves[i].properties);
                                    };
                                    spiderifier.spiderfy(features[0].geometry.coordinates, markers);
                                }
                            );
                        };
                    });
                    // Add hover events
                    map.on('mouseenter', 'clustered', () => {
                        map.getCanvas().style.cursor = 'pointer';
                    });
                    map.on('mouseleave', 'clustered', () => {
                        map.getCanvas().style.cursor = '';
                    });



                    // Add unclustered popup
                    // Add popup
                    let popup = new mapboxgl.Popup({
                        closeButton: true, // close button
                        closeOnClick: true, // close if click on map
                        closeOnMove: false, // close if move the map
                        anchor: 'bottom', // anchor of the popup
                        offset: 0, // offset from the feature
                        maxWidth: 'none', // max width of the popoup; 'none' to fit to the content                
                    });
                    // Add click event
                    function clickOnMap(e) {
                        // map.easeTo({
                        //     center: [e.features[0].geometry.coordinates[0], e.features[0].geometry.coordinates[1] + 0.0003],
                        //     zoom: 18,
                        // });
                        let coordinates = e.features[0].geometry.coordinates.slice(); // get point coordinates
                        let description = "<b>Photo ID: </b><span>" + e.features[0].properties.photo + "</span><br>"; // description in the popup
                        description += "<b>Datetime: </b><span>" + e.features[0].properties.datetime + "</span><br>";
                        description += "<a target='_blank' href='https://raw.githubusercontent.com/mayijun1203/PHOTOVIZGH/main/photo/" + e.features[0].properties.photo + "'><img src='https://raw.githubusercontent.com/mayijun1203/PHOTOVIZGH/main/photo/" + e.features[0].properties.photo + "' width=300rem>";
                        popup.setLngLat(coordinates).setHTML(description).addTo(map); //add popup
                    }
                    map.on('click', 'unclustered', clickOnMap);
                    // Add hover events
                    map.on('mouseenter', 'unclustered', function () {
                        map.getCanvas().style.cursor = 'pointer'; // mouse becoming pointer
                    });
                    map.on('mouseleave', 'unclustered', function () {
                        map.getCanvas().style.cursor = '';
                    });
                });
        });
    </script>
</body>

</html>